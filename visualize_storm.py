#!/usr/bin/env python
"""Discovered events and visualizes each event from a storm. It loops through
 DMSP files and using an OMNIweb file it finds events and writes an output CSV
file of events, and plots to disk.

This uses case files generated by util_make_case_file.py.
"""

import argparse
from datetime import datetime
import json
from matplotlib import MatplotlibDeprecationWarning
from matplotlib.colors import LogNorm
from matplotlib.dates import num2date
import pandas as pd
import numpy as np
import os
import pylab as plt
import pytz
from termcolor import cprint
import warnings

import lib_lockwood1992
import lib_search_dispersion 


def main():
    """Main routine of the program. Run with --help for description of arguments."""
    # Parse command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', metavar='CASE_FILE', required=True,
                        help='Path to case file')
    parser.add_argument('--no-plot', action='store_true',
                        help='Set to disable plotting')
    parser.add_argument('--simple-plots', action='store_true',
                        help='Do simple plots, without no algorithm information.')
    args = parser.parse_args()

    # Load case file ---------------------------------------------------------
    with open(args.i) as fh:
        case_file = json.load(fh)

    # Read OMNIWeb data all at once ------------------------------------------
    omniweb_fh = lib_search_dispersion.read_omniweb_files(
        case_file['OMNIWEB_FILES']
    )
        
    # Loop through files and call search_events() function
    # ------------------------------------------------------------------------    
    df_matches = []
    
    for i, dmsp_flux_file in enumerate(sorted(case_file['DMSP_FLUX_FILES'])):
        cprint(f'Processing {i+1}/{len(case_file["DMSP_FLUX_FILES"])} :: '
               f'{dmsp_flux_file}', 'green')
        
        df_match = search_events(
            dmsp_flux_file=dmsp_flux_file,
            omniweb_fh=omniweb_fh,
            outfolder=case_file['PLOT_OUTPUT'],
            no_plots=args.no_plot,
            reverse_effect=case_file['REVERSE_EFFECT'],
            simple_plots=args.simple_plots,
        )
        df_matches.append(df_match)

    df = pd.concat(df_matches).sort_values('start_time')

    # Write event list to console and output file ----------------------------
    cprint('Discovered events:', 'green')
    print(df.to_string(index=0))

    cprint('Writing event output (' + str(len(df.index)) + ' events) to '
           + case_file['EVENT_OUTPUT'], 'green')
    df.to_csv(case_file['EVENT_OUTPUT'], index=0)

    
def search_events(dmsp_flux_file, omniweb_fh, outfolder=None,
                  no_plots=False, reverse_effect=False, simple_plots=False):
    """Search for events in a DMSP file.
    
    Args
      dmsp_flux_file: Path to HDF5 DMSP file holding spectrogram data (daily)
      omniweb_fh: Loaded omniweb data in a dictionary
      outfolder: Path to write plots to (assuming no_plots=False)
      no_plots: Set to True to disable writing plots to disk
      reverse_effect: Search for effects in the opposite direction with a
        magnetic field set to the opposite of the coded threshold.
      simple_plots: Do not write D(t) and reconnection rate in plots
    Returns
      Pandas DataFrame holding events found in the file
    """
    # Do computation --------------------------------------------------
    from spacepy import pycdf
    try:
        dmsp_flux_fh = (
            lib_search_dispersion.read_dmsp_flux_file(dmsp_flux_file)
        )
    except pycdf.CDFError:
        return

    dEicdt_smooth, Eic_smooth, Eic = (
        lib_search_dispersion.estimate_log_Eic_smooth_derivative(dmsp_flux_fh)
    )

    df_match, integrand, _, _ = lib_search_dispersion.walk_and_integrate(
        dmsp_flux_fh, omniweb_fh, dEicdt_smooth, Eic_smooth,
        lib_search_dispersion.INTERVAL_LENGTH,
        reverse_effect=reverse_effect, return_integrand=True
    )
    
    # Do plotting --------------------------------------------------
    for _, row_match in df_match.iterrows():
        orig_i = dmsp_flux_fh['t'].searchsorted(row_match.start_time)
        orig_j = dmsp_flux_fh['t'].searchsorted(row_match.end_time)

        delta_index = int(1.2 * (orig_j - orig_i))  # make plot wider
        i = max(orig_i - delta_index, 0)
        j = min(orig_j + delta_index, dmsp_flux_fh['t'].size - 1)

        if simple_plots:
            fig, axes = plt.subplots(2, 1, figsize=(12, 6), sharex=True)
        else:
            small_size, med_size, big_size = 16, 18, 20
            plt.rc('font', size=small_size)          # controls default text sizes
            plt.rc('axes', titlesize=small_size)     # fontsize of the axes title
            plt.rc('axes', labelsize=med_size)       # fontsize of the x and y labels
            plt.rc('xtick', labelsize=small_size)    # fontsize of the tick labels
            plt.rc('ytick', labelsize=small_size)    # fontsize of the tick labels
            plt.rc('legend', fontsize=small_size)    # legend fontsize
            plt.rc('figure', titlesize=big_size)     # fontsize of the figure title
            fig, axes = plt.subplots(4, 1, figsize=(18, 12), sharex=True)
            
        # Plot title
        nonzero = (integrand[orig_i:orig_j] > 0.01).nonzero()[0]
        if nonzero.size > 0:
            first_pos_i = nonzero[0] - 1
            orig_i += first_pos_i
        time_length = row_match.end_time - dmsp_flux_fh['t'][orig_i]
        Bx, By, Bz = (
            row_match["Bx_mean"],
            row_match["By_mean"],
            row_match["Bz_mean"]
        )
        sat = None
        for sat_num in range(10, 100):
            if f'F{sat_num}' in dmsp_flux_file:
                sat = f'F{sat_num}'
                        
        if simple_plots:
            title = (
                f'DMSP {sat} Plasma Spectrograms'
            )
        else:            
            title = (
                f'DMSP {sat} Dispersion Event during '
                "$B_{IMF}$" + f' = ({Bx:.2f}, {By:.2f}, {Bz:.2f}) nT'
            )
            
        axes[0].set_title(title)
        
        # Ion spectrogram
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", MatplotlibDeprecationWarning)
            im = axes[0].pcolor(
                dmsp_flux_fh['t'][i:j],
                np.log10(dmsp_flux_fh['ch_energy']),
                dmsp_flux_fh['ion_d_ener'][:, i:j], 
                norm=LogNorm(vmin=1e3, vmax=1e8), cmap='jet'
            )
        plt.colorbar(im, ax=axes[0]).set_label('Energy Flux')

        #tcutoff = datetime(2015, 12, 20, 7, 48, 45, tzinfo=pytz.utc) # fig2.1
        #tcutoff = datetime(2015, 12, 21, 2, 28, 12, tzinfo=pytz.utc) # fig2.2

        if not simple_plots:
            tbin_centers = dmsp_flux_fh['t'][orig_i:orig_j]
            tbin_centers += 0.5 * np.diff(dmsp_flux_fh['t'][orig_i:orig_j+1])
        
            delta_e = np.log10(dmsp_flux_fh['ch_energy'][-1]) - \
                np.log10(dmsp_flux_fh['ch_energy'][-2])
            Eic_filtered = Eic[orig_i:orig_j].copy()
            Eic_filtered += 0.5 * delta_e
            top_e = np.log10(lib_search_dispersion.MAX_SHEATH_ENERGY)
            Eic_filtered[Eic_filtered > top_e] = np.nan

            #Eic_filtered[tbin_centers > tcutoff] = np.nan #fig2.1,fig2.2
            
            axes[0].plot(tbin_centers, Eic_filtered, 'b*-')
            axes[0].axhline(
                np.log10(lib_search_dispersion.MAX_EIC_ENERGY),
                color='black', linestyle='dashed'
            )
        axes[0].set_ylabel('Ions Energy [eV]')
        adjust_axis_energy_yticks(axes[0])
        
        # Electron Spectrogram
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", MatplotlibDeprecationWarning)
            im = axes[1].pcolor(
                dmsp_flux_fh['t'][i:j],
                np.log10(dmsp_flux_fh['ch_energy']),
                dmsp_flux_fh['el_d_ener'][:, i:j], 
                norm=LogNorm(vmin=1e5, vmax=1e10), cmap='jet'
            )
        plt.colorbar(im, ax=axes[1]).set_label('Energy Flux')
        axes[1].set_ylabel('Electrons Energy [eV]')
        adjust_axis_energy_yticks(axes[1])
        
        # Scoring function
        if not simple_plots:
            score_range = [-.25, .25]
            t = dmsp_flux_fh['t']
            #integrand[t > tcutoff] = np.nan # fig2.1,fig2.2
            
            axes[2].fill_between(t[orig_i:orig_j], 0, integrand[orig_i:orig_j])
            axes[2].axhline(0, color='black', linestyle='dashed')            
            axes[2].set_ylabel('D(t) [Log(eV)/s]')
            #axes[2].fill_between(
            #    [dmsp_flux_fh['t'][orig_i], dmsp_flux_fh['t'][orig_j]],
            #    *score_range, color='gray', alpha=0.35
            #)
            axes[2].set_ylim(score_range)
            plt.colorbar(im, ax=axes[2]).set_label('')
            
        # Reconnection Rate (Time Series)
        if not simple_plots:
            d, recon_rate = lib_lockwood1992.estimate_reconn_rate(
                dmsp_flux_fh, Eic, orig_i, orig_j
            )
            
            for cnt in range(len(d)):
                t = dmsp_flux_fh['t'][orig_i:orig_j]
                #recon_rate[cnt, :][t > tcutoff] = np.nan # fig2.1,fig.2.2
                axes[3].plot(t, recon_rate[cnt, :], 'o-', label=f'd\' = {d[cnt]} Re')
                
            axes[3].legend()
            axes[3].set_ylabel('Reconnection\nRate (mV/m)')
            axes[3].set_ylim([.01, 100])
            axes[3].set_yscale('log')
            axes[3].grid(linestyle='dashed', color='gray')
            plt.colorbar(im, ax=axes[3]).set_label('')

        #start_time = datetime(2015, 12, 20, 7, 47, 30, tzinfo=pytz.utc) # fig2.1
        #end_time = datetime(2015, 12, 20, 7, 50, 0, tzinfo=pytz.utc) # fig2.1
        #start_time = datetime(2015, 12, 21, 2, 26, 30, tzinfo=pytz.utc) # fig2.2
        #end_time = datetime(2015, 12, 21, 2, 29, 30, tzinfo=pytz.utc) # fig2.2
        #axes[-1].set_xlim([start_time, end_time]) # fig2.1,fig2.2

        add_multirow_xticks(axes[-1], dmsp_flux_fh, simple_plots)
        
        # Plot spacings
        plt.subplots_adjust(hspace=.05)
        plt.tight_layout()
        
        # Save image
        if not no_plots:
            out_name = outfolder + '/'
            out_name += f'{os.path.basename(dmsp_flux_file)}_'
            out_name += f"{row_match.start_time.isoformat()}_"
            out_name += f"{row_match.end_time.isoformat()}.png"

            os.makedirs(outfolder, exist_ok=True)
            plt.savefig(out_name)
            plt.close()
            
            cprint('Wrote plot ' + out_name, 'green')
            
            df_match['file'] = dmsp_flux_file
        
    return df_match


def add_multirow_xticks(ax, dmsp_flux_fh, simple_plots):
    """Add multirow tickmarks to the bottom axis as is common in the
    magnetospheres community.

    Args
      ax: matplotlib axes
      dmsp_flux_fh: file handle (as returned by read_dmsp_flux_file)
    """
    xticks = ax.get_xticks()
    new_labels = []
    
    for time_float in xticks:
        time = num2date(time_float)
        i = dmsp_flux_fh['t'].searchsorted(time)
        if i == dmsp_flux_fh['t'].size:
            continue
        mlat = dmsp_flux_fh['mlat'][i]
        mlt = dmsp_flux_fh['mlt'][i]
        
        new_label = '%s\n%.1f\n%.1f' % (
            time.strftime('%H:%M:%S'), mlat, mlt
        )
        new_labels.append(new_label)
        
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", UserWarning)
        ax.set_xticklabels(new_labels)
        
        if simple_plots:
            ax.text(-0.075, -0.075, 'Time', transform=ax.transAxes)
            ax.text(-0.075, -0.15, 'MLAT', transform=ax.transAxes)
            ax.text(-0.075, -0.225, 'MLT', transform=ax.transAxes)
        else:            
            ax.text(-0.09, -0.12, 'Time', transform=ax.transAxes)
            ax.text(-0.09, -0.24, 'MLAT', transform=ax.transAxes)
            ax.text(-0.09, -0.36, 'MLT', transform=ax.transAxes)

def adjust_axis_energy_yticks(ax):
    """Adjust yticklabels for axes with y-axis being energy.
    
    Sets them to terms like eV and keV.

    Args
      ax: matplotlib axes    
    """
    yticks = 10**ax.get_yticks()
    labels = []

    for ytick in yticks:
        if ytick < 1000:
            labels.append('%d eV' % ytick)
        else:
            labels.append('%.1f keV' % (ytick/1000))

    with warnings.catch_warnings():
        warnings.simplefilter("ignore", UserWarning)
        
        ax.set_yticklabels(labels)

    
    

if __name__ == '__main__':
    main()
