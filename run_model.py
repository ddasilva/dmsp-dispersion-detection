#!/usr/bin/env python
"""Discovered events and visualizes each events.

It loops through DMSP files and using an OMNIweb file it finds events and writes
an output CSV file of events, and plots to disk.

This uses case files generated by make_case_file.py.
"""

import argparse
import json
from matplotlib import MatplotlibDeprecationWarning
from matplotlib.colors import LogNorm
from matplotlib.dates import num2date
import pandas as pd
import numpy as np
import os
import pylab as plt
from spacepy import pycdf
from termcolor import cprint
import warnings

import lib_dasilva2022
import lib_util


def main():
    """Main routine of the program. Run with --help for description of arguments."""
    # Parse command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', metavar='CASE_FILE', required=True,
                        help='Path to case file')
    parser.add_argument('--no-plot', action='store_true',
                        help='Set to disable plotting')
    parser.add_argument('--simple-plots', action='store_true',
                        help='Do simple plots, without no algorithm information.')
    parser.add_argument('--threshold', type=float, default=-1)
    
    args = parser.parse_args()

    # Load case file ---------------------------------------------------------
    with open(args.i) as fh:
        case_file = json.load(fh)

    # Read OMNIWeb data all at once ------------------------------------------
    omniweb_fh = lib_util.read_omniweb_files(
        case_file['OMNIWEB_FILES']
    )
        
    # Loop through files and call search_events() function
    # ------------------------------------------------------------------------    
    df_matches = []
    
    for i, dmsp_flux_file in enumerate(sorted(case_file['DMSP_FLUX_FILES'])):
        cprint(f'Processing {i+1}/{len(case_file["DMSP_FLUX_FILES"])} :: '
               f'{dmsp_flux_file}', 'green')
        
        df_match = search_events(
            dmsp_flux_file=dmsp_flux_file,
            omniweb_fh=omniweb_fh,
            plot_out_dir=case_file['PLOT_OUTPUT'],
            no_plots=args.no_plot,
            reverse_effect=case_file['REVERSE_EFFECT'],
            inverse_effect=case_file['INVERSE_EFFECT'],
            simple_plots=args.simple_plots,
            integral_threshold=args.threshold,
        )
        df_matches.append(df_match)

    df = pd.concat(df_matches).sort_values('start_time')

    # Write event list to console and output file ----------------------------
    cprint('Discovered events:', 'green')
    print(df.to_string(index=0))

    cprint('Writing event output (' + str(len(df.index)) + ' events) to '
           + case_file['EVENT_OUTPUT'], 'green')
    df.to_csv(case_file['EVENT_OUTPUT'], index=0)

    
def search_events(dmsp_flux_file, omniweb_fh, plot_out_dir=None,
                  no_plots=False, reverse_effect=False, inverse_effect=False,                  
                  simple_plots=False, integral_threshold=None):
    """Search for events in a DMSP file.
    
    Args
      dmsp_flux_file: Path to HDF5 DMSP file holding spectrogram data (daily)
      omniweb_fh: Loaded omniweb data in a dictionary
      plot_out_dir: Path to write plots to (assuming no_plots=False)
      no_plots: Set to True to disable writing plots to disk
      reverse_effect: Search for effects in the opposite direction with a
        magnetic field set to the opposite of the coded threshold.
      simple_plots: Do not write D(t) and reconnection rate in plots
      integration: detection threhsold value, set to -1 for default.
    Returns
      Pandas DataFrame holding events found in the file
    """
    if integral_threshold < -1:
        integral_threshold = lib_dasilva2022.DEFAULT_INTEGRAL_THRESHOLD
    
    # Do computation --------------------------------------------------
    try:
        dmsp_flux_fh = lib_util.read_dmsp_flux_file(dmsp_flux_file)
    except pycdf.CDFError:
        return

    dEicdt_smooth, Eic_smooth, Eic = (
        lib_dasilva2022.estimate_log_Eic_smooth_derivative(dmsp_flux_fh)
    )
    
    df_match, integrand, _, _ = lib_dasilva2022.walk_and_integrate(
        dmsp_flux_fh, omniweb_fh, dEicdt_smooth, Eic_smooth,
        lib_dasilva2022.INTERVAL_LENGTH, integral_threshold,
        reverse_effect=reverse_effect, inverse_effect=inverse_effect,
        return_integrand=True
    )

    df_match['file'] = dmsp_flux_file
    
    # Do plotting --------------------------------------------------
    if not no_plots:
        for _, row_match in df_match.iterrows():
            write_plot(
                dmsp_flux_fh, row_match.start_time, row_match.end_time,
                row_match['Bx_mean'], row_match['By_mean'],
                row_match['Bz_mean'], dmsp_flux_file, simple_plots,
                plot_out_dir, integrand, Eic
            )

    return df_match


def write_plot(
    dmsp_flux_fh, start_time, end_time, Bx, By, Bz, dmsp_flux_file,
    simple_plots, plot_out_dir, integrand, Eic
):
    """Visualizes detection and writes plot to disk.

    Args
      dmsp_flux_fh: Dictionary of keys/values holding contents of the DMSP
        flux file.
      start_time: Beginning time of selection.
      end_time: Ending time of selection
      Bx: magnetic field x component
      By: magnetic field y component
      Bz: magnetic field z component
      dmsp_flux_file: Path to DMSP flux file
      simple_plots: Flag to enable simpler plot format
      plot_out_dir: Path to output directory
      integrand: array of integrand values
      Eic: array of Eic values
    """
    orig_i = dmsp_flux_fh['t'].searchsorted(start_time)
    orig_j = dmsp_flux_fh['t'].searchsorted(end_time)

    delta_index = int(1.2 * (orig_j - orig_i))  # make plot wider
    delta_index = int(2 * (orig_j - orig_i))  # make plot wider,dd,rd
    i = max(orig_i - delta_index, 0)
    j = min(orig_j + delta_index, dmsp_flux_fh['t'].size - 1)
    
    if simple_plots:
        fig, axes = plt.subplots(2, 1, figsize=(12, 6), sharex=True)
    else:
        small_size, med_size, big_size = 16, 18, 20
        plt.rc('font', size=small_size)          # controls default text sizes
        plt.rc('axes', titlesize=small_size)     # fontsize of the axes title
        plt.rc('axes', labelsize=med_size)       # fontsize of the x and y labels
        plt.rc('xtick', labelsize=small_size)    # fontsize of the tick labels
        plt.rc('ytick', labelsize=small_size)    # fontsize of the tick labels
        plt.rc('legend', fontsize=small_size)    # legend fontsize
        plt.rc('figure', titlesize=big_size)     # fontsize of the figure title
        fig, axes = plt.subplots(3, 1, figsize=(18, 9), sharex=True, dpi=600)
        
    # Plot title
    nonzero = (integrand[orig_i:orig_j] > 0.01).nonzero()[0]
    if nonzero.size > 0:
        first_pos_i = nonzero[0] - 1
        orig_i += first_pos_i

    sat = None
    for sat_num in range(10, 100):
        if f'F{sat_num}' in dmsp_flux_file:
            sat = f'F{sat_num}'
                        
    if simple_plots:
        title = (
            f'DMSP {sat} Plasma Spectrograms'
        )
    else:            
        title = (
            f'DMSP {sat} Dispersion Event during '
            "$B_{IMF}$" + f' = ({Bx:.2f}, {By:.2f}, {Bz:.2f}) nT\n'
            f"{start_time.isoformat()} - "
            f"{end_time.isoformat()}"
        )
            
    axes[0].set_title(title)
        
    # Ion spectrogram
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", MatplotlibDeprecationWarning)
        im = axes[0].pcolor(
            dmsp_flux_fh['t'][i:j],
            np.log10(dmsp_flux_fh['ch_energy']),
            dmsp_flux_fh['ion_d_ener'][:, i:j], 
            norm=LogNorm(vmin=1e3, vmax=1e8), cmap='jet'
        )
        plt.colorbar(im, ax=axes[0]).set_label('Energy Flux')
        
    if not simple_plots:
        tbin_centers = dmsp_flux_fh['t'][orig_i:orig_j]
        tbin_centers += 0.5 * np.diff(dmsp_flux_fh['t'][orig_i:orig_j+1])
        
        delta_e = np.log10(dmsp_flux_fh['ch_energy'][-1]) - \
            np.log10(dmsp_flux_fh['ch_energy'][-2])
        Eic_filtered = Eic[orig_i:orig_j].copy()
        Eic_filtered += 0.5 * delta_e
        top_e = np.log10(lib_dasilva2022.MAX_SHEATH_ENERGY)
        Eic_filtered[Eic_filtered > top_e] = np.nan
        
        if np.isnan(Eic_filtered).all():
            plt.close()
            return
        
        axes[0].plot(tbin_centers, Eic_filtered, 'b*-') 
        axes[0].axhline(
            np.log10(lib_dasilva2022.MAX_EIC_ENERGY),
            color='black', linestyle='dashed'
        )
    axes[0].set_ylabel('Ions Energy [eV]')
    adjust_axis_energy_yticks(axes[0])
        
    # Electron Spectrogram
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", MatplotlibDeprecationWarning)
        im = axes[1].pcolor(
            dmsp_flux_fh['t'][i:j],
            np.log10(dmsp_flux_fh['ch_energy']),
            dmsp_flux_fh['el_d_ener'][:, i:j], 
            norm=LogNorm(vmin=1e5, vmax=1e10), cmap='jet'
        )
    plt.colorbar(im, ax=axes[1]).set_label('Energy Flux')
    axes[1].set_ylabel('Electrons Energy [eV]')
    adjust_axis_energy_yticks(axes[1])
        
    # Scoring function
    if not simple_plots:
        score_range = [-.25, .25]
        t = dmsp_flux_fh['t']
        
        axes[2].fill_between(t[orig_i:orig_j], 0, integrand[orig_i:orig_j])
        axes[2].axhline(0, color='black', linestyle='dashed')            
        axes[2].set_ylabel('D(t) [Log(eV)/s]')
        axes[2].set_ylim(score_range)
        plt.colorbar(im, ax=axes[2]).set_label('')
        
    add_multirow_xticks(axes[-1], dmsp_flux_fh, simple_plots)
        
    # Plot spacings
    plt.subplots_adjust(hspace=.05)
    plt.tight_layout()
    
    # Save image
    out_name = plot_out_dir + '/'
    out_name += f'{os.path.basename(dmsp_flux_file)}_'
    out_name += f"{start_time.isoformat().replace(':', '')}_"
    out_name += f"{end_time.isoformat().replace(':', '')}.png"
    
    os.makedirs(plot_out_dir, exist_ok=True)
    plt.savefig(out_name)
    plt.close()
    
    cprint('Wrote plot ' + out_name, 'green')         


def add_multirow_xticks(ax, dmsp_flux_fh, simple_plots):
    """Add multirow tickmarks to the bottom axis as is common in the
    magnetospheres community.

    Args
      ax: matplotlib axes
      dmsp_flux_fh: file handle (as returned by read_dmsp_flux_file)
    """
    xticks = ax.get_xticks()
    new_labels = []
    
    for time_float in xticks:
        time = num2date(time_float)
        i = dmsp_flux_fh['t'].searchsorted(time)
        if i == dmsp_flux_fh['t'].size:
            continue
        mlat = dmsp_flux_fh['mlat'][i]
        mlt = dmsp_flux_fh['mlt'][i]
        
        new_label = '%s\n%.1f\n%.1f' % (
            time.strftime('%H:%M:%S'), mlat, mlt
        )
        new_labels.append(new_label)
        
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", UserWarning)
        ax.set_xticklabels(new_labels)
        
        if simple_plots:
            ax.text(-0.075, -0.075, 'Time', transform=ax.transAxes)
            ax.text(-0.075, -0.15, 'MLAT', transform=ax.transAxes)
            ax.text(-0.075, -0.225, 'MLT', transform=ax.transAxes)
        else:            
            ax.text(-0.09, -0.12, 'Time', transform=ax.transAxes)
            ax.text(-0.09, -0.24, 'MLAT', transform=ax.transAxes)
            ax.text(-0.09, -0.36, 'MLT', transform=ax.transAxes)

def adjust_axis_energy_yticks(ax):
    """Adjust yticklabels for axes with y-axis being energy.
    
    Sets them to terms like eV and keV.

    Args
      ax: matplotlib axes    
    """
    yticks = 10**ax.get_yticks()
    labels = []

    for ytick in yticks:
        if ytick < 1000:
            labels.append('%d eV' % ytick)
        else:
            labels.append('%.1f keV' % (ytick/1000))

    with warnings.catch_warnings():
        warnings.simplefilter("ignore", UserWarning)
        
        ax.set_yticklabels(labels)


if __name__ == '__main__':
    main()
